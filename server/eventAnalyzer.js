const weatherService = require('./services/weatherService');
const documentProcessor = require('./services/documentProcessor');
const EventAgent = require('./services/eventAgent');

class CalendarEventAnalyzer {
  constructor() {
    this.agent = new EventAgent();
  }

  async analyzeEvent(event, tokens = null, options = {}) {
    const { weatherData, weatherSuggestions } = await this.#fetchWeatherContext(event);
    const documentContext = await this.#fetchDocumentContext(event, tokens);
    const { 
      shouldAttemptMealPlan: shouldAttemptMealPlanPref = false,
      mealPlanPreferences = null
    } = options;

    try {
      const {
        text: responseText,
        mealPlanResult,
        shouldAttemptMealPlan,
        mealPlanError,
        mealPlanFallback
      } = await this.agent.analyzeEvent(event, {
        tokens,
        weatherSummary: weatherData ? buildWeatherSummary(weatherData, weatherSuggestions) : null,
        googleDocsContext: documentContext?.documents?.map(doc => ({
          title: doc.title,
          summary: doc.wasSummarized ? doc.text : doc.summary || doc.text
        })),
        wishlistContext: null,
        shouldAttemptMealPlan: shouldAttemptMealPlanPref,
        mealPlanPreferences: mealPlanPreferences
      });

      const analysis = this.parseOpenAIResponse(responseText);

      // Add weather data to the response if available
      if (weatherData) {
        analysis.weather = {
          temperature: weatherData.temperature,
          feelsLike: weatherData.feelsLike,
          description: weatherData.description,
          main: weatherData.main,
          precipitation: Math.round(weatherData.precipitation),
          windSpeed: weatherData.windSpeed,
          humidity: weatherData.humidity,
          location: weatherData.location,
          suggestions: weatherSuggestions,
          fetchedAt: new Date().toISOString(),
          queryLocation: event.location
        };
      }

      if (mealPlanResult && mealPlanResult.document) {
        console.log('[eventAnalyzer] Using Spoonacular meal plan with Google Doc');
        analysis.mealPlan = {
          document: {
            title: mealPlanResult.document.title,
            url: mealPlanResult.document.url,
            documentId: mealPlanResult.document.documentId
          },
          message: 'A personalized meal plan has been generated and saved to Google Docs.',
          preferences: mealPlanResult.preferences || null,
          nutrients: mealPlanResult.mealPlan?.nutrients || null,
          fallback: mealPlanResult.formattedText || null,
          source: 'spoonacular'
        };

        analysis.requiresMealPlanPreferences = false;

        if (analysis.preparationTasks && Array.isArray(analysis.preparationTasks)) {
          const existingTask = analysis.preparationTasks.find(task => task.isMealPlanTask);
          if (!existingTask) {
            analysis.preparationTasks.unshift({
              id: 'meal_plan_doc',
              task: 'Review Generated Meal Plan',
              priority: 'High',
              category: 'Meal Planning',
              estimatedTime: '10 minutes',
              suggestedDate: event.date,
              description: `View meal plan document: ${mealPlanResult.document.url}`,
              isMealPlanTask: true
            });
          }
        }
      } else if (mealPlanResult && mealPlanResult.formattedText) {
        // Tool succeeded but no document - show formatted text
        console.log('[eventAnalyzer] Using Spoonacular meal plan (no Google Doc)');
        analysis.mealPlan = {
          document: null,
          message: 'Meal plan generated from Spoonacular. Review the suggested menu below.',
          preferences: mealPlanResult.preferences || null,
          nutrients: mealPlanResult.mealPlan?.nutrients || null,
          fallback: mealPlanResult.formattedText,
          source: 'spoonacular'
        };
        analysis.requiresMealPlanPreferences = false;
      } else if (mealPlanFallback) {
        // LLM fallback succeeded - show it
        console.log('[eventAnalyzer] Using LLM-generated meal plan (Spoonacular fallback)');
        analysis.mealPlan = {
          fallback: mealPlanFallback,
          message: 'Meal plan generated by AI (Spoonacular API unavailable).',
          source: 'llm'
        };
        analysis.requiresMealPlanPreferences = false;
      } else if (shouldAttemptMealPlan && !mealPlanResult && !mealPlanFallback) {
        // Meal plan was attempted but both Spoonacular and LLM fallback failed
        // OR this is the first analysis and we need user preferences
        console.log('[eventAnalyzer] Meal plan generation failed or not attempted - requesting user preferences');
        analysis.requiresMealPlanPreferences = true;
        analysis.mealPlan = {
          message: 'Please provide your meal planning preferences to generate a personalized meal plan.',
          source: null
        };
      }
      // If both tool and fallback failed, don't set analysis.mealPlan
      // This prevents showing an empty meal plan section in the UI

      return analysis;
    } catch (error) {
      console.error('OpenAI API Error:', error);
      throw new Error(`Failed to analyze event with AI: ${error.message}`);
    }
  }

  async #fetchWeatherContext(event) {
    if (!event.location || !event.date) {
      return { weatherData: null, weatherSuggestions: [] };
    }

    try {
      const weatherData = await weatherService.getWeatherForEvent(event.location, event.date);
      if (!weatherData) {
        return { weatherData: null, weatherSuggestions: [] };
      }

      const weatherSuggestions = weatherService.generateWeatherSuggestions(
        weatherData,
        event.type,
        event.title
      );

      console.log(`ðŸŒ¤ï¸  Weather data fetched for ${event.location}: ${weatherData.description}`);

      return { weatherData, weatherSuggestions };
    } catch (error) {
      console.warn('Could not fetch weather data:', error.message);
      return { weatherData: null, weatherSuggestions: [] };
    }
  }

  async #fetchDocumentContext(event, tokens) {
    if (!event.description || !tokens) {
      return null;
    }

    try {
      const docResult = await documentProcessor.processDocuments(event.description, tokens);
      if (docResult && docResult.hasDocuments) {
        console.log(`ðŸ“„ Processed ${docResult.documents.length} document(s) for event analysis`);
        return docResult;
      }
    } catch (error) {
      console.warn('Could not process documents:', error.message);
    }

    return null;
  }

  parseOpenAIResponse(content) {
    try {
      // Try to parse the JSON response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        
        // Ensure all suggested dates/times are in the future
        if (parsed.preparationTasks && Array.isArray(parsed.preparationTasks)) {
          parsed.preparationTasks = parsed.preparationTasks.map(task => {
            if (task.suggestedDate) {
              task.suggestedDate = this.ensureFutureDate(task.suggestedDate);
            }
            return task;
          });
        }
        
        return parsed;
      }
      
      // If no JSON found, throw error
      throw new Error('Invalid JSON response from OpenAI');
    } catch (error) {
      console.error('Error parsing OpenAI response:', error);
      // Return a fallback response structure
      return {
        eventSummary: "Analysis could not be completed due to response format error.",
        preparationTasks: [
          {
            task: "Review event details manually",
            priority: "Medium",
            category: "Planning",
            estimatedTime: "10 minutes"
          }
        ],
        timeline: {
          "1 day before": ["Review event details"]
        },
        tips: ["Double-check event time and location"],
        estimatedPrepTime: "30 minutes"
      };
    }
  }

  /**
   * Ensure the suggested date is in the future
   * If the date is in the past, adjust it to be at least 1 hour from now
   * @param {string} suggestedDate - ISO date string
   * @returns {string} ISO date string in the future
   */
  ensureFutureDate(suggestedDate) {
    try {
      const now = new Date();
      const suggested = new Date(suggestedDate);
      
      // If suggested date is in the past or less than 1 hour from now, adjust it
      const oneHourFromNow = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour from now
      
      if (suggested <= oneHourFromNow) {
        // Set to 1 hour from now
        return oneHourFromNow.toISOString();
      }
      
      return suggested.toISOString();
    } catch (error) {
      console.error('Error ensuring future date:', error);
      // If parsing fails, return 1 hour from now
      const oneHourFromNow = new Date(Date.now() + 60 * 60 * 1000);
      return oneHourFromNow.toISOString();
    }
  }


}

function buildWeatherSummary(weatherData, suggestions) {
  const lines = [];
  lines.push('Weather Forecast:');
  lines.push(`- Location: ${weatherData.location}`);
  lines.push(`- Temperature: ${weatherData.temperature}Â°C (Feels like ${weatherData.feelsLike}Â°C)`);
  lines.push(`- Conditions: ${weatherData.description}`);
  lines.push(`- Precipitation: ${Math.round(weatherData.precipitation)}% chance`);
  lines.push(`- Wind: ${weatherData.windSpeed} km/h`);
  lines.push(`- Humidity: ${weatherData.humidity}%`);
  if (suggestions?.length) {
    lines.push('Weather-based suggestions:');
    suggestions.forEach(s => lines.push(`- ${s}`));
  }
  return lines.join('\n');
}

module.exports = CalendarEventAnalyzer;
